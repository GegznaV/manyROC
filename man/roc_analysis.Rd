% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/print-methods.R, R/roc_analysis.R
\name{print.roc_df}
\alias{print.roc_df}
\alias{print.roc_opt_result}
\alias{print.roc_info}
\alias{roc_analysis}
\title{[!] Carry out the ROC analysis}
\usage{
\method{print}{roc_df}(x, ..., show_all = FALSE, perf_digits = 2,
  fmt = "\%.3g")

\method{print}{roc_opt_result}(x, digits = 3, ...)

\method{print}{roc_info}(x, ...)

roc_analysis(x, gr, pos_label = levels(gr)[2], pos_is_larger = NULL,
  optimize_by = "bac", results = "all")
}
\arguments{
\item{x}{(\code{numeric}) \cr A numeric vector.\cr
(in \code{print} function) An object to print.}

\item{...}{[!!!] Passed to further methods.}

\item{show_all}{(\code{logical(1)})\cr A flag if whole dataset should be
printed. If \code{FALSE}, only a few fisrt and last rows
will be printed.}

\item{perf_digits}{(\code{integer(1)})\cr A number of decimals to display
for \emph{performance measures}. Default is 2.}

\item{fmt}{(\code{character(1)})\cr A string indicating number display
format for other numeric columns excluding performance measures.
The string will be passed to \code{\link[base]{sprintf}}.
Default is \code{"\%.3g"}.}

\item{digits}{(\code{integer(1)})\cr Number of significant digits to display.}

\item{gr}{(\code{factor}) \cr A factor vector with two levels.}

\item{pos_label}{(\code{character(1)}) \cr A string with the name of
positive group.}

\item{pos_is_larger}{(\code{NULL}|\code{TRUE}|\code{FALSE}) \cr
A flag indicating, if values of positive group are on avedage
are expected to be larger than values of negative group.
If \code{NULL}, this option is determined basing on data using
group medians.}

\item{optimize_by}{(\code{string(1)}) \cr [!!!] Method to determine the
optimal cut-off value.
Current options: \code{"bac"},
                \code{"youden"},
                \code{"kappa"}.}

\item{results}{(\code{character(1)}) \cr A string indicating which results
should be returned: either \code{"all"} (as described in
section "Values") or just \code{"optimal"}.}
}
\value{
A list (which also inherits from class \code{"roc_result_list"})
with three fields: \code{$info}, \code{$optimal}, \code{$all_results}.
\itemize{

\item \bold{\code{$info}} is a data frame with columns
     \code{var_name} - empty string reserved for variable name,
     \code{neg_label}, \code{pos_label} labels of negative and positive
                             groups respectively,
     \code{n_neg}, \code{n_pos}, \code{n_total} - number of negative
and positive cases as well as number of cases in total.

\item \bold{\code{$optimal}} one row from \code{$all_results}, which was
determined as having optima threshold (cut-off) value. Sometimes it can be
several rows, if the performance is equally good. \cr\cr

\item \bold{\code{$all_results}} is a data frame with columns
      \code{cutoffs} for cutoff values,
      \code{tp} (number of true positives),
      \code{fn} (number of false negatives),
      \code{fp} (number of false positives),
      \code{tn} (number of true negatives),
      ... [!!!]

}\cr\cr
}
\description{
Do the ROC (receiver operating characteristic) analysis and calculate
vector of cut-off values and associated number of
true positives (TP),
false negatives (FN),
false positives (FP), and
true negatives (TN) as well as performance measures such as sensitivity,
specificity, etc.
\cr[!!!]
}
\note{
This function is inspired by functions \code{predict} and
\code{.compute.unnormalized.roc.curve} from \pkg{ROCR} package.
}
\examples{
library(multiROC)
library(ggplot2)

# Make some data

set.seed(1)
(x <- rnorm(10))

(gr <- gl(n = 2, k = 5, length = 10, labels = c("H","S")))


# Explore the functions

roc_analysis(x, gr)

roc_analysis(x, gr, pos_label = "H")


# --- Example 2 ---

set.seed(1)
x2 = c(rnorm(50, mean = 14), rnorm(50, mean = 20))
gr2 = gl(2, 50, labels = c("Neg", "Pos"))

(roc_rez<- roc_analysis(x2, gr2))

optimal_cutoff2 <- roc_rez$optimal[1]

qplot(x2, fill = gr2, color = gr2,
      geom = c("density", "rug"), alpha = I(0.3)) +
   geom_vline(xintercept = optimal_cutoff2)


# --- Example 3 ---

set.seed(1)
x3 = c(rnorm(100, mean = 11), rnorm(100, mean = 14))
gr3 = gl(2, 100, labels = c("Neg", "Pos"))

(roc_rez3 <- roc_analysis(x3, gr3))

optimal_cutoff3 <- roc_rez3$optimal[1]

qplot(x3, fill = gr3, color = gr3,
     geom = c("density", "rug"), alpha = I(0.3)) +
    geom_vline(xintercept = roc_rez3$optimal[1])


}
\seealso{
Other functions for ROC: \code{\link{access_elements}},
  \code{\link{calculate_performance}},
  \code{\link{roc_performance_measures}},
  \code{\link{roc_predict}}
}
\author{
Vilmantas Gegzna
}
